"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.isStringElement = exports.isSourceMapElement = exports.isRefElement = exports.isPrimitiveElement = exports.isParseResultElement = exports.isObjectElement = exports.isNumberElement = exports.isNullElement = exports.isMemberElement = exports.isLinkElement = exports.isElement = exports.isCommentElement = exports.isBooleanElement = exports.isArrayElement = exports.isAnnotationElement = exports.includesSymbols = exports.includesClasses = exports.hasElementSourceMap = void 0;
var _minim = require("minim");
var _ramda = require("ramda");
var _ramdaAdjunct = require("ramda-adjunct");
var _Annotation = _interopRequireDefault(require("../elements/Annotation.cjs"));
var _Comment = _interopRequireDefault(require("../elements/Comment.cjs"));
var _ParseResult = _interopRequireDefault(require("../elements/ParseResult.cjs"));
var _SourceMap = _interopRequireDefault(require("../elements/SourceMap.cjs"));
var _helpers = _interopRequireWildcard(require("./helpers.cjs"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const isElement = (0, _helpers.default)(({
  hasBasicElementProps,
  primitiveEq
}) => {
  return element => element instanceof _minim.Element || hasBasicElementProps(element) && primitiveEq(undefined, element);
});
exports.isElement = isElement;
const isStringElement = (0, _helpers.default)(({
  hasBasicElementProps,
  primitiveEq
}) => {
  return element => element instanceof _minim.StringElement || hasBasicElementProps(element) && primitiveEq('string', element);
});
exports.isStringElement = isStringElement;
const isNumberElement = (0, _helpers.default)(({
  hasBasicElementProps,
  primitiveEq
}) => {
  return element => element instanceof _minim.NumberElement || hasBasicElementProps(element) && primitiveEq('number', element);
});
exports.isNumberElement = isNumberElement;
const isNullElement = (0, _helpers.default)(({
  hasBasicElementProps,
  primitiveEq
}) => {
  return element => element instanceof _minim.NullElement || hasBasicElementProps(element) && primitiveEq('null', element);
});
exports.isNullElement = isNullElement;
const isBooleanElement = (0, _helpers.default)(({
  hasBasicElementProps,
  primitiveEq
}) => {
  return element => element instanceof _minim.BooleanElement || hasBasicElementProps(element) && primitiveEq('boolean', element);
});
exports.isBooleanElement = isBooleanElement;
const isObjectElement = (0, _helpers.default)(({
  hasBasicElementProps,
  primitiveEq,
  hasMethod
}) => {
  return element => element instanceof _minim.ObjectElement || hasBasicElementProps(element) && primitiveEq('object', element) && hasMethod('keys', element) && hasMethod('values', element) && hasMethod('items', element);
});
exports.isObjectElement = isObjectElement;
const isArrayElement = (0, _helpers.default)(({
  hasBasicElementProps,
  primitiveEq,
  hasMethod
}) => {
  return element => element instanceof _minim.ArrayElement && !(element instanceof _minim.ObjectElement) || hasBasicElementProps(element) && primitiveEq('array', element) && hasMethod('push', element) && hasMethod('unshift', element) && hasMethod('map', element) && hasMethod('reduce', element);
});
exports.isArrayElement = isArrayElement;
const isMemberElement = (0, _helpers.default)(({
  hasBasicElementProps,
  isElementType,
  primitiveEq
}) => {
  return element => element instanceof _minim.MemberElement || hasBasicElementProps(element) && isElementType('member', element) && primitiveEq(undefined, element);
});
exports.isMemberElement = isMemberElement;
const isLinkElement = (0, _helpers.default)(({
  hasBasicElementProps,
  isElementType,
  primitiveEq
}) => {
  return element => element instanceof _minim.LinkElement || hasBasicElementProps(element) && isElementType('link', element) && primitiveEq(undefined, element);
});
exports.isLinkElement = isLinkElement;
const isRefElement = (0, _helpers.default)(({
  hasBasicElementProps,
  isElementType,
  primitiveEq
}) => {
  return element => element instanceof _minim.RefElement || hasBasicElementProps(element) && isElementType('ref', element) && primitiveEq(undefined, element);
});
exports.isRefElement = isRefElement;
const isAnnotationElement = (0, _helpers.default)(({
  hasBasicElementProps,
  isElementType,
  primitiveEq
}) => {
  return element => element instanceof _Annotation.default || hasBasicElementProps(element) && isElementType('annotation', element) && primitiveEq('array', element);
});
exports.isAnnotationElement = isAnnotationElement;
const isCommentElement = (0, _helpers.default)(({
  hasBasicElementProps,
  isElementType,
  primitiveEq
}) => {
  return element => element instanceof _Comment.default || hasBasicElementProps(element) && isElementType('comment', element) && primitiveEq('string', element);
});
exports.isCommentElement = isCommentElement;
const isParseResultElement = (0, _helpers.default)(({
  hasBasicElementProps,
  isElementType,
  primitiveEq
}) => {
  return element => element instanceof _ParseResult.default || hasBasicElementProps(element) && isElementType('parseResult', element) && primitiveEq('array', element);
});
exports.isParseResultElement = isParseResultElement;
const isSourceMapElement = (0, _helpers.default)(({
  hasBasicElementProps,
  isElementType,
  primitiveEq
}) => {
  return element => element instanceof _SourceMap.default || hasBasicElementProps(element) && isElementType('sourceMap', element) && primitiveEq('array', element);
});
exports.isSourceMapElement = isSourceMapElement;
const isPrimitiveElement = element => {
  return (0, _helpers.isElementType)('object', element) || (0, _helpers.isElementType)('array', element) || (0, _helpers.isElementType)('boolean', element) || (0, _helpers.isElementType)('number', element) || (0, _helpers.isElementType)('string', element) || (0, _helpers.isElementType)('null', element) || (0, _helpers.isElementType)('member', element);
};
exports.isPrimitiveElement = isPrimitiveElement;
const hasElementSourceMap = element => {
  var _element$meta, _element$meta$get;
  return isSourceMapElement(element === null || element === void 0 ? void 0 : (_element$meta = element.meta) === null || _element$meta === void 0 ? void 0 : (_element$meta$get = _element$meta.get) === null || _element$meta$get === void 0 ? void 0 : _element$meta$get.call(_element$meta, 'sourceMap'));
};
exports.hasElementSourceMap = hasElementSourceMap;
const includesSymbols = (symbols, element) => {
  if (symbols.length === 0) {
    return true;
  }
  const elementSymbols = element.attributes.get('symbols');
  if (!isArrayElement(elementSymbols)) {
    return false;
  }
  return (0, _ramda.all)((0, _ramdaAdjunct.included)(elementSymbols.toValue()), symbols);
};
exports.includesSymbols = includesSymbols;
const includesClasses = (classes, element) => {
  if (classes.length === 0) {
    return true;
  }
  return (0, _ramda.all)((0, _ramdaAdjunct.included)(element.classes.toValue()), classes);
};
exports.includesClasses = includesClasses;