"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.visit = exports.keyMapDefault = exports.isNode = exports.getNodeType = exports.PredicateVisitor = void 0;
var _stampit = _interopRequireDefault(require("stampit"));
var _ramda = require("ramda");
var _ramdaAdjunct = require("ramda-adjunct");
var _apidomAst = require("@swagger-api/apidom-ast");
exports.BREAK = _apidomAst.BREAK;
exports.mergeAllVisitors = _apidomAst.mergeAllVisitors;
var _index = require("../predicates/index.cjs");
// getNodeType :: Node -> String
const getNodeType = element => {
  /*
   * We're translating every possible higher element type to primitive minim type here.
   * We're using polymorphism to recognize any higher element type as ObjectElement or ArrayElement.
   * Using polymorphism allows us to assume any namespace.
   *
   * There is a problem with naming visitor methods described here: https://github.com/babel/babel/discussions/12874
   */
  /* eslint-disable no-nested-ternary */
  return (0, _index.isObjectElement)(element) ? 'ObjectElement' : (0, _index.isArrayElement)(element) ? 'ArrayElement' : (0, _index.isMemberElement)(element) ? 'MemberElement' : (0, _index.isStringElement)(element) ? 'StringElement' : (0, _index.isBooleanElement)(element) ? 'BooleanElement' : (0, _index.isNumberElement)(element) ? 'NumberElement' : (0, _index.isNullElement)(element) ? 'NullElement' : (0, _index.isLinkElement)(element) ? 'LinkElement' : (0, _index.isRefElement)(element) ? 'RefElement' : undefined;
  /* eslint-enable */
};

// isNode :: Node -> Boolean
exports.getNodeType = getNodeType;
const isNode = (0, _ramda.curryN)(1, (0, _ramda.pipe)(getNodeType, _ramdaAdjunct.isString));
exports.isNode = isNode;
const keyMapDefault = {
  ObjectElement: ['content'],
  ArrayElement: ['content'],
  MemberElement: ['key', 'value'],
  StringElement: [],
  BooleanElement: [],
  NumberElement: [],
  NullElement: [],
  RefElement: [],
  LinkElement: [],
  Annotation: [],
  Comment: [],
  ParseResultElement: ['content'],
  SourceMap: ['content']
};
exports.keyMapDefault = keyMapDefault;
const PredicateVisitor = (0, _stampit.default)({
  props: {
    result: [],
    predicate: _ramda.F,
    returnOnTrue: undefined,
    returnOnFalse: undefined
  },
  init({
    // @ts-ignore
    predicate = this.predicate,
    // @ts-ignore
    returnOnTrue = this.returnOnTrue,
    // @ts-ignore
    returnOnFalse = this.returnOnFalse
  } = {}) {
    this.result = [];
    this.predicate = predicate;
    this.returnOnTrue = returnOnTrue;
    this.returnOnFalse = returnOnFalse;
  },
  methods: {
    enter(element) {
      if (this.predicate(element)) {
        this.result.push(element);
        return this.returnOnTrue;
      }
      return this.returnOnFalse;
    }
  }
});

// @ts-ignore
exports.PredicateVisitor = PredicateVisitor;
const visit = (root,
// @ts-ignore
visitor, {
  keyMap = keyMapDefault,
  ...rest
} = {}) => {
  // @ts-ignore
  return (0, _apidomAst.visit)(root, visitor, {
    // @ts-ignore
    keyMap,
    // @ts-ignore
    nodeTypeGetter: getNodeType,
    nodePredicate: isNode,
    ...rest
  });
};

// @ts-ignore
exports.visit = visit;
visit[Symbol.for('nodejs.util.promisify.custom')] = async (root,
// @ts-ignore
visitor, {
  keyMap = keyMapDefault,
  ...rest
} = {}) => {
  // @ts-ignore
  return _apidomAst.visit[Symbol.for('nodejs.util.promisify.custom')](root, visitor, {
    // @ts-ignore
    keyMap,
    // @ts-ignore
    nodeTypeGetter: getNodeType,
    nodePredicate: isNode,
    ...rest
  });
};