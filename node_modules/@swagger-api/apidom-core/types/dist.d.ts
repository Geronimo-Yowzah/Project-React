/// <reference path="./minim.d.ts" />
/// <reference types="ts-toolbelt" />
import { Element, Namespace as Namespace$1, NamespacePlugin, StringElement, Meta, Attributes, ArrayElement, ArraySlice, ObjectElement } from 'minim';
export { ArrayElement, ArraySlice, Attributes, BooleanElement, Element, KeyValuePair, LinkElement, MemberElement, Meta, NamespacePluginOptions, NullElement, NumberElement, ObjectElement, ObjectSlice, RefElement, StringElement, refract } from 'minim';
import * as Function_Curry from 'Function/Curry';
import { Pred } from 'ramda';
import stampit from 'stampit';
export { BREAK, mergeAllVisitors } from '@swagger-api/apidom-ast';

declare const dispatchPlugins: <T extends Element>(element: T, plugins: any[], options?: {}) => T;

/**
 * Plugin for decorating every element in ApiDOM tree with UUID.
 */
declare const plugin$1: ({ length }?: {
    length?: number | undefined;
}) => () => {
    pre(): void;
    visitor: {
        enter<T extends Element>(element: T): void;
    };
    post(): void;
};

/**
 * Plugin for decorating every semantic element in ApiDOM tree with UUID.
 */
type Predicates = {
    isPrimitiveElement: (element: Element) => boolean;
};
declare const plugin: ({ length }?: {
    length?: number | undefined;
}) => ({ predicates }: {
    predicates: Predicates;
}) => {
    pre(): void;
    visitor: {
        enter<T extends Element>(element: T): void;
    };
    post(): void;
};

declare class MediaTypes<T> extends Array<T> {
    unknownMediaType: string;
    filterByFormat(): void;
    findBy(): void;
    latest(): void;
}

declare class Namespace extends Namespace$1 {
    constructor();
}
declare const namespace: Namespace;
declare const createNamespace: (namespacePlugin?: NamespacePlugin) => Namespace;

declare class Annotation extends StringElement {
    constructor(content?: string, meta?: Meta, attributes?: Attributes);
    get code(): any;
    set code(value: any);
}

declare class Comment extends StringElement {
    constructor(content?: string, meta?: Meta, attributes?: Attributes);
}

declare class ParseResult extends ArrayElement {
    constructor(content?: Array<any>, meta?: Meta, attributes?: Attributes);
    get api(): Element | undefined;
    get results(): ArraySlice;
    get result(): Element | undefined;
    get annotations(): ArraySlice;
    get warnings(): ArraySlice;
    get errors(): ArraySlice;
    get isEmpty(): boolean;
    replaceResult(replacement: Element): boolean;
}

interface Position {
    row: number;
    column: number;
    char: number;
}
interface PositionRange {
    start: Position;
    end: Position;
}
declare class SourceMap extends ArrayElement {
    constructor(content?: Array<any>, meta?: Meta, attributes?: Attributes);
    get positionStart(): Element | undefined;
    get positionEnd(): Element | undefined;
    set position(position: PositionRange | null);
}

declare const isElement: (element: any) => boolean;
declare const isStringElement: (element: any) => boolean;
declare const isNumberElement: (element: any) => boolean;
declare const isNullElement: (element: any) => boolean;
declare const isBooleanElement: (element: any) => boolean;
declare const isObjectElement: (element: any) => boolean;
declare const isArrayElement: (element: any) => boolean;
declare const isMemberElement: (element: any) => boolean;
declare const isLinkElement: (element: any) => boolean;
declare const isRefElement: (element: any) => boolean;
declare const isAnnotationElement: (element: any) => boolean;
declare const isParseResultElement: (element: any) => boolean;
declare const isSourceMapElement: (element: any) => boolean;
declare const isPrimitiveElement: (element: any) => boolean;
declare const hasElementSourceMap: (element: any) => boolean;
declare const includesSymbols: <T extends Element>(symbols: string[], element: T) => boolean;
declare const includesClasses: <T extends Element>(classes: string[], element: T) => boolean;

declare const hasMethod: (name: string, obj: Record<string, unknown>) => boolean;
declare const hasBasicElementProps: (element: any) => boolean;
declare const primitiveEq: (val: unknown, obj: any) => boolean;
declare const hasClass: (cls: string, obj: any) => boolean;
declare const isElementType: (name: string, element: any) => boolean;
interface PredicateHelpers {
    hasMethod: typeof hasMethod;
    hasBasicElementProps: typeof hasBasicElementProps;
    primitiveEq: typeof primitiveEq;
    isElementType: typeof isElementType;
    hasClass: typeof hasClass;
}
type PredicateCreator = (helpers: PredicateHelpers) => (element: any) => boolean;
declare const createPredicate: (predicateCreator: PredicateCreator) => (element: any) => boolean;

declare const filter: Function_Curry.Curry<(<T extends Element>(predicate: Pred, element: T) => ArraySlice)>;

declare const find: Function_Curry.Curry<(<T extends Element>(predicate: Pred, element: T) => T | undefined)>;

interface FindAtOffsetOptions {
    offset: number;
    includeRightBound?: boolean;
}
declare const findAtOffset: Function_Curry.Curry<(<T extends Element>(options: number | FindAtOffsetOptions, element: T) => T | undefined)>;

declare const reject: Function_Curry.Curry<(<T extends Element>(predicate: Pred, element: T) => ArraySlice)>;

declare const some: Function_Curry.Curry<(<T extends Element>(predicate: Pred, element: T) => boolean)>;

type Callback = <T extends Element>(element: T) => void;
interface TraverseOptions {
    callback?: Callback;
    predicate?: Pred;
}
declare const traverse: Function_Curry.Curry<(<T extends Element>(options: Callback | TraverseOptions, element: T) => void)>;

declare const parents: <T extends Element>(element: T) => WeakMap<Element, Element>;

declare const getNodeType: <T extends Element>(element: T) => string | undefined;
declare const keyMapDefault: {
    ObjectElement: string[];
    ArrayElement: string[];
    MemberElement: string[];
    StringElement: never[];
    BooleanElement: never[];
    NumberElement: never[];
    NullElement: never[];
    RefElement: never[];
    LinkElement: never[];
    Annotation: never[];
    Comment: never[];
    ParseResultElement: string[];
    SourceMap: string[];
};
declare const visit: (root: Element, visitor: any, { keyMap, ...rest }?: {
    keyMap?: {
        ObjectElement: string[];
        ArrayElement: string[];
        MemberElement: string[];
        StringElement: never[];
        BooleanElement: never[];
        NumberElement: never[];
        NullElement: never[];
        RefElement: never[];
        LinkElement: never[];
        Annotation: never[];
        Comment: never[];
        ParseResultElement: string[];
        SourceMap: string[];
    } | undefined;
}) => Element;

interface Transcluder {
    transclude(search: Element, replace: Element): Element | undefined;
}
/**
 * This is a mutating stamp. If you don't want your Element to be mutated,
 * clone in before passing it to initializer of this stamp.
 */
declare const Transcluder: stampit.Stamp<Transcluder>;

/**
 * This is a mutating function. If you don't want your Element to be mutated,
 * clone in before passing it to this function.
 */
declare const transclude: (search: Element, replace: Element, element: Element) => Element | undefined;

/**
 * This dereference algorithm is used exclusively for dereferencing specification objects.
 * It doesn't handle circular references of external references and works on objects only (not arrays).
 */
declare const dereference: (object: Record<string, any>, root?: Record<string, any>) => Record<string, any>;

declare const sexprs: (element: Element) => string;

type ObjectOrArrayElement = ObjectElement | ArrayElement;
type AnyElement = ObjectElement | ArrayElement | Element;
type DeepMerge = (targetElement: ObjectOrArrayElement, sourceElement: ObjectOrArrayElement, options?: DeepMergeOptions) => AnyElement;
type CustomMerge = (keyElement: Element, options: DeepMergeOptions) => DeepMerge;
type ArrayElementMerge = (targetElement: ArrayElement, sourceElement: ArrayElement, options: DeepMergeOptions) => ArrayElement;
type ObjectElementMerge = (targetElement: ObjectElement, source: ObjectElement, options: DeepMergeOptions) => ObjectElement;
type DeepMergeUserOptions = {
    clone?: boolean;
    isMergeableElement?: (element: Element) => boolean;
    arrayElementMerge?: ArrayElementMerge;
    objectElementMerge?: ObjectElementMerge;
    customMerge?: CustomMerge;
};
type DeepMergeOptions = DeepMergeUserOptions & {
    clone: boolean;
    isMergeableElement: (element: Element) => boolean;
    arrayElementMerge: ArrayElementMerge;
    objectElementMerge: ObjectElementMerge;
    customMerge: CustomMerge | undefined;
};
declare function deepmerge(targetElement: ObjectOrArrayElement, sourceElement: ObjectOrArrayElement, options?: DeepMergeUserOptions): AnyElement;
declare namespace deepmerge {
    var all: (list: ObjectOrArrayElement[], options?: DeepMergeOptions | undefined) => any;
}

/**
 * Transforms data to an Element from a particular namespace.
 */
declare const from: (data: any, namespace?: Namespace$1) => Element;
/**
 * Transforms the ApiDOM into JavaScript POJO.
 * This POJO would be the result of interpreting the ApiDOM
 * into JavaScript structure.
 */
declare const toValue: <T extends Element>(element: T) => any;
/**
 * Transforms the ApiDOM into JSON string.
 */
declare const toJSON: (element: Element, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined) => string;
/**
 * Transforms the ApiDOM into YAML string.
 */
declare const toYAML: (element: Element, { directive }?: {
    directive?: boolean | undefined;
}) => string;
/**
 * Creates a refract representation of an Element.
 * https://github.com/refractproject/refract-spec
 */
declare const dehydrate: (element: Element, namespace?: Namespace$1) => any;
/**
 * Create a refracted string representation of an Element.
 */
declare const toString: (element: Element, namespace?: Namespace$1) => string;

export { Annotation as AnnotationElement, Comment as CommentElement, MediaTypes, Namespace, ParseResult as ParseResultElement, SourceMap as SourceMapElement, Transcluder, createNamespace, createPredicate, deepmerge, dehydrate, dereference, dispatchPlugins as dispatchRefractorPlugins, filter, find, findAtOffset, from, getNodeType, hasElementSourceMap, includesClasses, includesSymbols, isAnnotationElement, isArrayElement, isBooleanElement, isElement, isLinkElement, isMemberElement, isNullElement, isNumberElement, isObjectElement, isParseResultElement, isPrimitiveElement, isRefElement, isSourceMapElement, isStringElement, keyMapDefault as keyMap, namespace, parents, plugin$1 as refractorPluginElementIdentity, plugin as refractorPluginSemanticElementIdentity, reject, sexprs, some, toJSON, toString, toValue, toYAML, transclude, traverse, visit };
