const hasMethod = (name, obj) => typeof (obj === null || obj === void 0 ? void 0 : obj[name]) === 'function';
const hasBasicElementProps = element => element != null && Object.prototype.hasOwnProperty.call(element, '_storedElement') && Object.prototype.hasOwnProperty.call(element, '_content');
const primitiveEq = (val, obj) => {
  var _obj$primitive;
  return (obj === null || obj === void 0 ? void 0 : (_obj$primitive = obj.primitive) === null || _obj$primitive === void 0 ? void 0 : _obj$primitive.call(obj)) === val;
};
const hasClass = (cls, obj) => {
  var _obj$classes, _obj$classes$includes;
  return (obj === null || obj === void 0 ? void 0 : (_obj$classes = obj.classes) === null || _obj$classes === void 0 ? void 0 : (_obj$classes$includes = _obj$classes.includes) === null || _obj$classes$includes === void 0 ? void 0 : _obj$classes$includes.call(_obj$classes, cls)) || false;
};
export const isElementType = (name, element) => (element === null || element === void 0 ? void 0 : element.element) === name;
const createPredicate = predicateCreator => {
  // @ts-ignore
  return predicateCreator({
    hasMethod,
    hasBasicElementProps,
    primitiveEq,
    isElementType,
    hasClass
  });
};
export default createPredicate;